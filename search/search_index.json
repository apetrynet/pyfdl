{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PyFDL NOTE! PyFDL is under development and should not be used in production PyFDL is a toolkit to parse and produce Framing Decision List (FDL) files in python. In addition to parsing FDL files, PyFDL aims to provide sample applications/plugins to apply framing intents described in the FDL. PyFDL is modeled around the official spec . Install Until a package is available on PyPi, you'll need to install PyFDL manually. It's recommended to install packages like this in a virtual environment. Installing from PyPi pip install pyfdl Installing directly from main branch on GitHub (At your own risk) pip install git+https://github.com/apetrynet/pyfdl.git When working on a contribution If you're working a contribution to this project you can save some time by installing the package like described below. This way you won't need to reinstall the package for every change you do to the code. # Replace PROJECT_ROOT with the root of this project cd [PROJECT_ROOT] pip install -e .","title":"Welcome to PyFDL"},{"location":"#welcome-to-pyfdl","text":"NOTE! PyFDL is under development and should not be used in production PyFDL is a toolkit to parse and produce Framing Decision List (FDL) files in python. In addition to parsing FDL files, PyFDL aims to provide sample applications/plugins to apply framing intents described in the FDL. PyFDL is modeled around the official spec .","title":"Welcome to PyFDL"},{"location":"#install","text":"Until a package is available on PyPi, you'll need to install PyFDL manually. It's recommended to install packages like this in a virtual environment.","title":"Install"},{"location":"#installing-from-pypi","text":"pip install pyfdl","title":"Installing from PyPi"},{"location":"#installing-directly-from-main-branch-on-github-at-your-own-risk","text":"pip install git+https://github.com/apetrynet/pyfdl.git","title":"Installing directly from main branch on GitHub (At your own risk)"},{"location":"#when-working-on-a-contribution","text":"If you're working a contribution to this project you can save some time by installing the package like described below. This way you won't need to reinstall the package for every change you do to the code. # Replace PROJECT_ROOT with the root of this project cd [PROJECT_ROOT] pip install -e .","title":"When working on a contribution"},{"location":"getting_started/","text":"Getting Started Install NOTE! Please note that at the time of writing this PyFDL is not released on PyPi. Please refer to README.md for instructions. pip install pyfdl About rounding As different parts of a pipeline requires different levels of precision we have an option to round values of dimensions accordingly. A canvas+framing decision for a \"raw\" camera canvas should in theory keep more precision than a canvas+framing decision for a conformed VFX plate. The rules for rounding strategy are the same as for CanvasTemplate.round The default strategy is to round dimensions to even numbers, but this may be overridden by setting the rounding strategy to NO_ROUNDING Here are a couple examples of setting the rounding strategy: import pyfdl fdl = pyfdl.FDL() # No rounding may either be set by passing the NO_ROUNDING variable fdl.set_rounding_strategy(pyfdl.NO_ROUNDING) # Or by explicitly passing None fdl.set_rounding_strategy(None) # For other requirements pass a dictionary with the rules fdl.set_rounding_strategy({'even': 'whole', 'mode': 'up'}) Examples Create an FDL from scratch import pyfdl from pyfdl import Canvas, FramingIntent, DimensionsInt, DimensionsFloat, Point from io import StringIO fdl = pyfdl.FDL() # Applying defaults will provide you with a valid staring point fdl.apply_defaults() # Let's create a framing intent framing_intent = FramingIntent( label=\"1.78-1 Framing\", id_=\"FDLSMP03\", aspect_ratio=DimensionsInt(width=16, height=9), protection=0.088 ) # Add the newly created framing intent to our FDL fdl.framing_intents.add_item(framing_intent) # Now let's create a canvas canvas = Canvas( label=\"Open Gate RAW\", id_=\"20220310\", source_canvas_id=\"20220310\", dimensions=DimensionsInt(width=5184, height=4320), effective_dimensions=DimensionsInt(width=5184, height=4320), effective_anchor_point=Point(x=0, y=0), photosite_dimensions=DimensionsInt(5184, height=4320), physical_dimensions=DimensionsFloat(width=25.92, height=21.60), anamorphic_squeeze=1.30 ) # Let's now add our canvas to the FDL within a context. # If no such context exists, one will be created for you. fdl.place_canvas_in_context(context_label=\"PanavisionDXL2\", canvas=canvas) # Finally, let's create a framing decision canvas.place_framing_intent(framing_intent=framing_intent) # Validate our FDL and save it (using StringIO as example) with StringIO() as f: pyfdl.dump(fdl, f, validate=True) Create a Canvas from a Canvas Template import pyfdl from io import StringIO from pathlib import Path fdl_file = Path('tests/sample_data/Scenario-9__OriginalFDL_UsedToMakePlate.fdl') with fdl_file.open('r') as f: fdl = pyfdl.load(f) # Select the first canvas in the first context context = fdl.contexts[0] source_canvas = context.canvases[0] # Select the first canvas template canvas_template = fdl.canvas_templates[0] # We know we want to use the first framing decision of the source canvas, so we pass index 0 # You may also pass the actual `FramingDecision` source_canvas.framing_decisions[0] new_canvas = pyfdl.Canvas.from_canvas_template( canvas_template=canvas_template, source_canvas=source_canvas, source_framing_decision=0 ) # Place the new canvas along side the source fdl.place_canvas_in_context(context_label=context.label, canvas=new_canvas) # Validate and \"save\" with StringIO() as f: pyfdl.dump(fdl, f, validate=True)","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#install","text":"NOTE! Please note that at the time of writing this PyFDL is not released on PyPi. Please refer to README.md for instructions. pip install pyfdl","title":"Install"},{"location":"getting_started/#about-rounding","text":"As different parts of a pipeline requires different levels of precision we have an option to round values of dimensions accordingly. A canvas+framing decision for a \"raw\" camera canvas should in theory keep more precision than a canvas+framing decision for a conformed VFX plate. The rules for rounding strategy are the same as for CanvasTemplate.round The default strategy is to round dimensions to even numbers, but this may be overridden by setting the rounding strategy to NO_ROUNDING Here are a couple examples of setting the rounding strategy: import pyfdl fdl = pyfdl.FDL() # No rounding may either be set by passing the NO_ROUNDING variable fdl.set_rounding_strategy(pyfdl.NO_ROUNDING) # Or by explicitly passing None fdl.set_rounding_strategy(None) # For other requirements pass a dictionary with the rules fdl.set_rounding_strategy({'even': 'whole', 'mode': 'up'})","title":"About rounding"},{"location":"getting_started/#examples","text":"","title":"Examples"},{"location":"getting_started/#create-an-fdl-from-scratch","text":"import pyfdl from pyfdl import Canvas, FramingIntent, DimensionsInt, DimensionsFloat, Point from io import StringIO fdl = pyfdl.FDL() # Applying defaults will provide you with a valid staring point fdl.apply_defaults() # Let's create a framing intent framing_intent = FramingIntent( label=\"1.78-1 Framing\", id_=\"FDLSMP03\", aspect_ratio=DimensionsInt(width=16, height=9), protection=0.088 ) # Add the newly created framing intent to our FDL fdl.framing_intents.add_item(framing_intent) # Now let's create a canvas canvas = Canvas( label=\"Open Gate RAW\", id_=\"20220310\", source_canvas_id=\"20220310\", dimensions=DimensionsInt(width=5184, height=4320), effective_dimensions=DimensionsInt(width=5184, height=4320), effective_anchor_point=Point(x=0, y=0), photosite_dimensions=DimensionsInt(5184, height=4320), physical_dimensions=DimensionsFloat(width=25.92, height=21.60), anamorphic_squeeze=1.30 ) # Let's now add our canvas to the FDL within a context. # If no such context exists, one will be created for you. fdl.place_canvas_in_context(context_label=\"PanavisionDXL2\", canvas=canvas) # Finally, let's create a framing decision canvas.place_framing_intent(framing_intent=framing_intent) # Validate our FDL and save it (using StringIO as example) with StringIO() as f: pyfdl.dump(fdl, f, validate=True)","title":"Create an FDL from scratch"},{"location":"getting_started/#create-a-canvas-from-a-canvas-template","text":"import pyfdl from io import StringIO from pathlib import Path fdl_file = Path('tests/sample_data/Scenario-9__OriginalFDL_UsedToMakePlate.fdl') with fdl_file.open('r') as f: fdl = pyfdl.load(f) # Select the first canvas in the first context context = fdl.contexts[0] source_canvas = context.canvases[0] # Select the first canvas template canvas_template = fdl.canvas_templates[0] # We know we want to use the first framing decision of the source canvas, so we pass index 0 # You may also pass the actual `FramingDecision` source_canvas.framing_decisions[0] new_canvas = pyfdl.Canvas.from_canvas_template( canvas_template=canvas_template, source_canvas=source_canvas, source_framing_decision=0 ) # Place the new canvas along side the source fdl.place_canvas_in_context(context_label=context.label, canvas=new_canvas) # Validate and \"save\" with StringIO() as f: pyfdl.dump(fdl, f, validate=True)","title":"Create a Canvas from a Canvas Template"},{"location":"top_level_functions/","text":"Top Level Functions These functions follow the convention of other file parsing packages like python's builtin json package and provide both reading and writing to and from strings and objects. pyfdl.load(fp, validate=True) Load an FDL from a file. Parameters: fp ( IO ) \u2013 file pointer validate ( bool , default: True ) \u2013 validate incoming json with jsonschema Raises: ValidationError \u2013 if the contents doesn't follow the spec Returns: FDL ( FDL ) \u2013 pyfdl.loads(s, validate=True) Load an FDL from string. Parameters: s ( str ) \u2013 string representation of an FDL validate ( bool , default: True ) \u2013 validate incoming json with jsonschema Returns: FDL ( FDL ) \u2013 pyfdl.dump(obj, fp, validate=True, indent=2) Dump an FDL to a file. Parameters: obj ( FDL ) \u2013 object to serialize fp ( IO ) \u2013 file pointer validate ( bool , default: True ) \u2013 validate outgoing json with jsonschema indent ( Union [ int , None] , default: 2 ) \u2013 amount of spaces pyfdl.dumps(obj, validate=True, indent=2) Dump an FDL to string Parameters: obj ( FDL ) \u2013 object to serialize validate ( bool , default: True ) \u2013 validate outgoing json with jsonschema indent ( Union [ int , None] , default: 2 ) \u2013 amount of spaces Returns: string ( str ) \u2013 representation of the resulting json","title":"Top Level Functions"},{"location":"top_level_functions/#top-level-functions","text":"These functions follow the convention of other file parsing packages like python's builtin json package and provide both reading and writing to and from strings and objects.","title":"Top Level Functions"},{"location":"top_level_functions/#pyfdl.load","text":"Load an FDL from a file. Parameters: fp ( IO ) \u2013 file pointer validate ( bool , default: True ) \u2013 validate incoming json with jsonschema Raises: ValidationError \u2013 if the contents doesn't follow the spec Returns: FDL ( FDL ) \u2013","title":"load"},{"location":"top_level_functions/#pyfdl.loads","text":"Load an FDL from string. Parameters: s ( str ) \u2013 string representation of an FDL validate ( bool , default: True ) \u2013 validate incoming json with jsonschema Returns: FDL ( FDL ) \u2013","title":"loads"},{"location":"top_level_functions/#pyfdl.dump","text":"Dump an FDL to a file. Parameters: obj ( FDL ) \u2013 object to serialize fp ( IO ) \u2013 file pointer validate ( bool , default: True ) \u2013 validate outgoing json with jsonschema indent ( Union [ int , None] , default: 2 ) \u2013 amount of spaces","title":"dump"},{"location":"top_level_functions/#pyfdl.dumps","text":"Dump an FDL to string Parameters: obj ( FDL ) \u2013 object to serialize validate ( bool , default: True ) \u2013 validate outgoing json with jsonschema indent ( Union [ int , None] , default: 2 ) \u2013 amount of spaces Returns: string ( str ) \u2013 representation of the resulting json","title":"dumps"},{"location":"Classes/canvas/","text":"Canvas pyfdl.Canvas(label=None, id_=None, source_canvas_id=None, dimensions=None, effective_dimensions=None, effective_anchor_point=None, photosite_dimensions=None, physical_dimensions=None, anamorphic_squeeze=None, framing_decisions=None) Bases: Base adjust_effective_anchor_point() Adjust the effective_anchor_point of this Canvas if effective_dimensions are set from_canvas_template(canvas_template, source_canvas, source_framing_decision=0) classmethod Create a new Canvas from the provided source_canvas and framing_decision based on a CanvasTemplate Parameters: canvas_template ( CanvasTemplate ) \u2013 describing how to handle incoming Canvas and FramingDecision source_canvas ( Canvas ) \u2013 to use as base for new canvas source_framing_decision ( Union [ FramingDecision , int ] , default: 0 ) \u2013 either a FramingDecision from the source canvas or the index ( int ) of one. Returns: canvas ( Canvas ) \u2013 based on the provided canvas template and sources get_dimensions() Get the most relevant dimensions and anchor point for the canvas. effective_dimensions and effective_anchor_point win over dimensions Returns: ( dimensions , anchor_point ) \u2013 place_framing_intent(framing_intent) Create a new FramingDecision based on the provided FramingIntent and add it to the collection of framing decisions. The framing decision's properties are calculated for you. If the canvas has effective dimensions set, these will be used for the calculations. Otherwise, we use the dimensions Parameters: framing_intent ( FramingIntent ) \u2013 framing intent to place in canvas Returns: framing_decision_id ( str ) \u2013 id of the newly created framing decision","title":"Canvas"},{"location":"Classes/canvas/#canvas","text":"","title":"Canvas"},{"location":"Classes/canvas/#pyfdl.Canvas","text":"Bases: Base","title":"Canvas"},{"location":"Classes/canvas/#pyfdl.Canvas.adjust_effective_anchor_point","text":"Adjust the effective_anchor_point of this Canvas if effective_dimensions are set","title":"adjust_effective_anchor_point"},{"location":"Classes/canvas/#pyfdl.Canvas.from_canvas_template","text":"Create a new Canvas from the provided source_canvas and framing_decision based on a CanvasTemplate Parameters: canvas_template ( CanvasTemplate ) \u2013 describing how to handle incoming Canvas and FramingDecision source_canvas ( Canvas ) \u2013 to use as base for new canvas source_framing_decision ( Union [ FramingDecision , int ] , default: 0 ) \u2013 either a FramingDecision from the source canvas or the index ( int ) of one. Returns: canvas ( Canvas ) \u2013 based on the provided canvas template and sources","title":"from_canvas_template"},{"location":"Classes/canvas/#pyfdl.Canvas.get_dimensions","text":"Get the most relevant dimensions and anchor point for the canvas. effective_dimensions and effective_anchor_point win over dimensions Returns: ( dimensions , anchor_point ) \u2013","title":"get_dimensions"},{"location":"Classes/canvas/#pyfdl.Canvas.place_framing_intent","text":"Create a new FramingDecision based on the provided FramingIntent and add it to the collection of framing decisions. The framing decision's properties are calculated for you. If the canvas has effective dimensions set, these will be used for the calculations. Otherwise, we use the dimensions Parameters: framing_intent ( FramingIntent ) \u2013 framing intent to place in canvas Returns: framing_decision_id ( str ) \u2013 id of the newly created framing decision","title":"place_framing_intent"},{"location":"Classes/canvas_template/","text":"Canvas Template pyfdl.CanvasTemplate(label=None, id_=None, target_dimensions=None, target_anamorphic_squeeze=None, fit_source=None, fit_method=None, alignment_method_vertical=None, alignment_method_horizontal=None, preserve_from_source_canvas=None, maximum_dimensions=None, pad_to_maximum=None, round_=None) Bases: Base fit_source_to_target(source_dimensions, source_anamorphic_squeeze) Calculate the dimensions of fit_source inside target_dimensions based on fit_mode Parameters: source_dimensions ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 source_anamorphic_squeeze ( float ) \u2013 Returns: size ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 get_desqueezed_width(source_width, squeeze_factor) Get the de-squeezed width also considering the target_anamorphic_squeeze . Used to calculate scaling of canvases and framing decisions. If target_anamorphic_squeeze is 0, it's considered \"same as source\" and no de-squeeze is applied. Parameters: source_width ( Union [ float , int ] ) \u2013 from source Canvas or FramingDecision squeeze_factor ( float ) \u2013 source Canvas.anamorphic_squeeze Returns: width ( Union [ float , int ] ) \u2013 scaled to size get_scale_factor(source_dimensions, source_anamorphic_squeeze) Calculate the scale factor used when creating a new Canvas and FramingDecision Parameters: source_dimensions ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 source_anamorphic_squeeze ( float ) \u2013 Returns: scale_factor ( float ) \u2013 get_transfer_keys() Get a list of attributes to transfer from source to destination in the order that preserves all attributes between fit_source and preserve_from_canvas Returns: keys ( List [ str ] ) \u2013","title":"Canvas Template"},{"location":"Classes/canvas_template/#canvas-template","text":"","title":"Canvas Template"},{"location":"Classes/canvas_template/#pyfdl.CanvasTemplate","text":"Bases: Base","title":"CanvasTemplate"},{"location":"Classes/canvas_template/#pyfdl.CanvasTemplate.fit_source_to_target","text":"Calculate the dimensions of fit_source inside target_dimensions based on fit_mode Parameters: source_dimensions ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 source_anamorphic_squeeze ( float ) \u2013 Returns: size ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013","title":"fit_source_to_target"},{"location":"Classes/canvas_template/#pyfdl.CanvasTemplate.get_desqueezed_width","text":"Get the de-squeezed width also considering the target_anamorphic_squeeze . Used to calculate scaling of canvases and framing decisions. If target_anamorphic_squeeze is 0, it's considered \"same as source\" and no de-squeeze is applied. Parameters: source_width ( Union [ float , int ] ) \u2013 from source Canvas or FramingDecision squeeze_factor ( float ) \u2013 source Canvas.anamorphic_squeeze Returns: width ( Union [ float , int ] ) \u2013 scaled to size","title":"get_desqueezed_width"},{"location":"Classes/canvas_template/#pyfdl.CanvasTemplate.get_scale_factor","text":"Calculate the scale factor used when creating a new Canvas and FramingDecision Parameters: source_dimensions ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 source_anamorphic_squeeze ( float ) \u2013 Returns: scale_factor ( float ) \u2013","title":"get_scale_factor"},{"location":"Classes/canvas_template/#pyfdl.CanvasTemplate.get_transfer_keys","text":"Get a list of attributes to transfer from source to destination in the order that preserves all attributes between fit_source and preserve_from_canvas Returns: keys ( List [ str ] ) \u2013","title":"get_transfer_keys"},{"location":"Classes/common/","text":"Common Global Variables Version numbers are used as default values in Header and to select a matching json schema file if no version is set. pyfdl.FDL_SCHEMA_MAJOR = 1 module-attribute pyfdl.FDL_SCHEMA_MINOR = 0 module-attribute pyfdl.FDL_SCHEMA_VERSION = {'major': FDL_SCHEMA_MAJOR, 'minor': FDL_SCHEMA_MINOR} module-attribute Different workflows have different requirements for precision, so we are flexible in how to apply rounding of values pyfdl.DEFAULT_ROUNDING_STRATEGY = {'even': 'even', 'mode': 'round'} module-attribute This is the default behavior for rounding the values of dimensions. The rules are the same as for CanvasTemplate.round . pyfdl.NO_ROUNDING = {} module-attribute This will disable rounding of values in dimensions. Exception being Canvas.dimensions when created by a canvas templates Base Classes Below is a collection of the common classes that are used by other classes. pyfdl.Base(*args, **kwargs) Bases: ABC Base class not to be instanced directly. Parameters: *args ( Any , default: () ) \u2013 **kwargs ( Any , default: {} ) \u2013 Attributes: attributes \u2013 list of attributes described in FDL spec kwarg_map \u2013 map attribute names that clash with reserved builtin python functions to safe alternatives like: (id -> id_) and (uuid -> _uuid) object_map \u2013 map attributes to custom classes required \u2013 list of required attributes. Supports linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set defaults \u2013 map default values to attributes. In addition to primitive values supports: callable, subclasses of Base apply_defaults() Applies default values defined in the defaults attribute to attributes that are None check_required() Check that required attributes contain values. Checks linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set Returns: list \u2013 a list of missing attributes from_dict(raw) classmethod Create instances of classes from a provided dict. Parameters: raw ( dict ) \u2013 dictionary to convert to supported classes Returns: cls ( Any ) \u2013 and instance of the current class set_rounding_strategy(rules=DEFAULT_ROUNDING_STRATEGY) classmethod Set the global rounding strategy for dimensions. The rules are the same as for CanvasTemplate.round but are passed as a dictionary. Passing None to the rule argument will disable all rounding for dimensions. Default rules are: {'even': 'even', 'mode': 'round'} Available options: even \"whole\" = to nearest integer, \"even\" = to nearest even-numbered integer mode \"up\" = always round up, \"down\" = always round down \"round\" = standard rounding: >= +0.5 rounds up and < +0.5 rounds down Parameters: rules ( Union [ dict , None] , default: DEFAULT_ROUNDING_STRATEGY ) \u2013 will default to {'even': 'even', 'mode': 'round'} if rules is None to_dict() Produce a dictionary representation of the current object along with all sub objects. Raises: FDLError \u2013 if required keys are missing Returns: dict \u2013 representation of object pyfdl.TypedCollection(cls) Collection only accepting items of a given class. In addition, a strict control of unique id's is enforced. Parameters: cls ( Any ) \u2013 type of class to be accepted add_item(item) Add an item to the collection. All items added to a collection get associated to the collection by passing itself as parent Parameters: item ( Any ) \u2013 of type passed at instancing of the collection. Raises: FDLError \u2013 for missing id or if a duplicate id is detected get_item(item_id) Get an item in the collection Parameters: item_id ( str ) \u2013 id of item you'd like to get Returns: item ( Union [ Any , None] ) \u2013 in collection or None if not found remove_item(item_id) Remove an item in the collection if found Parameters: item_id ( str ) \u2013 id of item to be removed pyfdl.DimensionsFloat(width, height) Bases: Base Dimensions properly formatted and stored as floats Parameters: width ( float ) \u2013 height ( float ) \u2013 copy() Create a copy of these dimensions Returns: copy ( DimensionsFloat ) \u2013 of these dimensions scale_by(factor) Scale the dimensions by the provider factor Parameters: factor ( float ) \u2013 pyfdl.DimensionsInt(width, height) Bases: Base Dimensions properly formatted and stored as ints Parameters: width ( int ) \u2013 height ( int ) \u2013 copy() Create a copy of these dimensions Returns: copy ( DimensionsInt ) \u2013 of these dimensions scale_by(factor) Scale the dimensions by the provider factor Parameters: factor ( float ) \u2013 pyfdl.Point(x, y) Bases: Base Point properly formatted Parameters: x ( float ) \u2013 y ( float ) \u2013 pyfdl.RoundStrategy(even=None, mode=None) Bases: Base Describes how to handle rounding canvas dimensions when applying a CanvasTemplate . Parameters: even ( str , default: None ) \u2013 \"whole\" = to nearest integer, \"even\" = to nearest even-numbered integer mode ( str , default: None ) \u2013 \"up\" = always round up, \"down\" = always round down \"round\" = standard rounding, >= +0.5 rounds up,< +0.5 rounds down Raises: FDLError \u2013 if you provide a value other than the ones listed above round_dimensions(dimensions) Round the provided dimensions based on the rules defined in this object Parameters: dimensions ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 Returns: dimensions ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 rounded based on rules","title":"Common"},{"location":"Classes/common/#common","text":"","title":"Common"},{"location":"Classes/common/#global-variables","text":"Version numbers are used as default values in Header and to select a matching json schema file if no version is set.","title":"Global Variables"},{"location":"Classes/common/#pyfdl.FDL_SCHEMA_MAJOR","text":"","title":"FDL_SCHEMA_MAJOR"},{"location":"Classes/common/#pyfdl.FDL_SCHEMA_MINOR","text":"","title":"FDL_SCHEMA_MINOR"},{"location":"Classes/common/#pyfdl.FDL_SCHEMA_VERSION","text":"Different workflows have different requirements for precision, so we are flexible in how to apply rounding of values","title":"FDL_SCHEMA_VERSION"},{"location":"Classes/common/#pyfdl.DEFAULT_ROUNDING_STRATEGY","text":"This is the default behavior for rounding the values of dimensions. The rules are the same as for CanvasTemplate.round .","title":"DEFAULT_ROUNDING_STRATEGY"},{"location":"Classes/common/#pyfdl.NO_ROUNDING","text":"This will disable rounding of values in dimensions. Exception being Canvas.dimensions when created by a canvas templates","title":"NO_ROUNDING"},{"location":"Classes/common/#base-classes","text":"Below is a collection of the common classes that are used by other classes.","title":"Base Classes"},{"location":"Classes/common/#pyfdl.Base","text":"Bases: ABC Base class not to be instanced directly. Parameters: *args ( Any , default: () ) \u2013 **kwargs ( Any , default: {} ) \u2013 Attributes: attributes \u2013 list of attributes described in FDL spec kwarg_map \u2013 map attribute names that clash with reserved builtin python functions to safe alternatives like: (id -> id_) and (uuid -> _uuid) object_map \u2013 map attributes to custom classes required \u2013 list of required attributes. Supports linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set defaults \u2013 map default values to attributes. In addition to primitive values supports: callable, subclasses of Base","title":"Base"},{"location":"Classes/common/#pyfdl.Base.apply_defaults","text":"Applies default values defined in the defaults attribute to attributes that are None","title":"apply_defaults"},{"location":"Classes/common/#pyfdl.Base.check_required","text":"Check that required attributes contain values. Checks linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set Returns: list \u2013 a list of missing attributes","title":"check_required"},{"location":"Classes/common/#pyfdl.Base.from_dict","text":"Create instances of classes from a provided dict. Parameters: raw ( dict ) \u2013 dictionary to convert to supported classes Returns: cls ( Any ) \u2013 and instance of the current class","title":"from_dict"},{"location":"Classes/common/#pyfdl.Base.set_rounding_strategy","text":"Set the global rounding strategy for dimensions. The rules are the same as for CanvasTemplate.round but are passed as a dictionary. Passing None to the rule argument will disable all rounding for dimensions. Default rules are: {'even': 'even', 'mode': 'round'} Available options: even \"whole\" = to nearest integer, \"even\" = to nearest even-numbered integer mode \"up\" = always round up, \"down\" = always round down \"round\" = standard rounding: >= +0.5 rounds up and < +0.5 rounds down Parameters: rules ( Union [ dict , None] , default: DEFAULT_ROUNDING_STRATEGY ) \u2013 will default to {'even': 'even', 'mode': 'round'} if rules is None","title":"set_rounding_strategy"},{"location":"Classes/common/#pyfdl.Base.to_dict","text":"Produce a dictionary representation of the current object along with all sub objects. Raises: FDLError \u2013 if required keys are missing Returns: dict \u2013 representation of object","title":"to_dict"},{"location":"Classes/common/#pyfdl.TypedCollection","text":"Collection only accepting items of a given class. In addition, a strict control of unique id's is enforced. Parameters: cls ( Any ) \u2013 type of class to be accepted","title":"TypedCollection"},{"location":"Classes/common/#pyfdl.TypedCollection.add_item","text":"Add an item to the collection. All items added to a collection get associated to the collection by passing itself as parent Parameters: item ( Any ) \u2013 of type passed at instancing of the collection. Raises: FDLError \u2013 for missing id or if a duplicate id is detected","title":"add_item"},{"location":"Classes/common/#pyfdl.TypedCollection.get_item","text":"Get an item in the collection Parameters: item_id ( str ) \u2013 id of item you'd like to get Returns: item ( Union [ Any , None] ) \u2013 in collection or None if not found","title":"get_item"},{"location":"Classes/common/#pyfdl.TypedCollection.remove_item","text":"Remove an item in the collection if found Parameters: item_id ( str ) \u2013 id of item to be removed","title":"remove_item"},{"location":"Classes/common/#pyfdl.DimensionsFloat","text":"Bases: Base Dimensions properly formatted and stored as floats Parameters: width ( float ) \u2013 height ( float ) \u2013","title":"DimensionsFloat"},{"location":"Classes/common/#pyfdl.DimensionsFloat.copy","text":"Create a copy of these dimensions Returns: copy ( DimensionsFloat ) \u2013 of these dimensions","title":"copy"},{"location":"Classes/common/#pyfdl.DimensionsFloat.scale_by","text":"Scale the dimensions by the provider factor Parameters: factor ( float ) \u2013","title":"scale_by"},{"location":"Classes/common/#pyfdl.DimensionsInt","text":"Bases: Base Dimensions properly formatted and stored as ints Parameters: width ( int ) \u2013 height ( int ) \u2013","title":"DimensionsInt"},{"location":"Classes/common/#pyfdl.DimensionsInt.copy","text":"Create a copy of these dimensions Returns: copy ( DimensionsInt ) \u2013 of these dimensions","title":"copy"},{"location":"Classes/common/#pyfdl.DimensionsInt.scale_by","text":"Scale the dimensions by the provider factor Parameters: factor ( float ) \u2013","title":"scale_by"},{"location":"Classes/common/#pyfdl.Point","text":"Bases: Base Point properly formatted Parameters: x ( float ) \u2013 y ( float ) \u2013","title":"Point"},{"location":"Classes/common/#pyfdl.RoundStrategy","text":"Bases: Base Describes how to handle rounding canvas dimensions when applying a CanvasTemplate . Parameters: even ( str , default: None ) \u2013 \"whole\" = to nearest integer, \"even\" = to nearest even-numbered integer mode ( str , default: None ) \u2013 \"up\" = always round up, \"down\" = always round down \"round\" = standard rounding, >= +0.5 rounds up,< +0.5 rounds down Raises: FDLError \u2013 if you provide a value other than the ones listed above","title":"RoundStrategy"},{"location":"Classes/common/#pyfdl.RoundStrategy.round_dimensions","text":"Round the provided dimensions based on the rules defined in this object Parameters: dimensions ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 Returns: dimensions ( Union [ DimensionsInt , DimensionsFloat ] ) \u2013 rounded based on rules","title":"round_dimensions"},{"location":"Classes/context/","text":"Context pyfdl.Context(label=None, context_creator=None, canvases=None) Bases: Base","title":"Context"},{"location":"Classes/context/#context","text":"","title":"Context"},{"location":"Classes/context/#pyfdl.Context","text":"Bases: Base","title":"Context"},{"location":"Classes/errors/","text":"Errors pyfdl.FDLError Bases: Exception","title":"Errors"},{"location":"Classes/errors/#errors","text":"","title":"Errors"},{"location":"Classes/errors/#pyfdl.FDLError","text":"Bases: Exception","title":"FDLError"},{"location":"Classes/fdl/","text":"FDL The FDL class is meant to be an entry point and is a \"merge\" between a Header class and container class. The Header is created for you based on the arguments you provide at initialisation or you can pass a Header object as an attribute if you wish. pyfdl.FDL(_uuid=None, version=None, fdl_creator=None, default_framing_intent=None, framing_intents=None, contexts=None, canvas_templates=None) Bases: Base header: Header property writable Returns: Header ( Header ) \u2013 based on attributes apply_defaults() Applies default values defined in the defaults attribute to attributes that are None check_required() Check that required attributes contain values. Checks linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set Returns: list \u2013 a list of missing attributes validate() Validate the current state of the FDL. ID's and relationships between items are checked and values are validated against the json schema. Raises: FDLValidationError \u2013 if any errors are found from_dict(raw) classmethod Create instances of classes from a provided dict. Parameters: raw ( dict ) \u2013 dictionary to convert to supported classes Returns: cls ( Any ) \u2013 and instance of the current class to_dict() Produce a dictionary representation of the current object along with all sub objects. Raises: FDLError \u2013 if required keys are missing Returns: dict \u2013 representation of object load_schema() Load a jsonschema based on the version in Header or default to current version set in base Returns: schema ( dict ) \u2013 place_canvas_in_context(context_label, canvas) Place a canvas in a context. If no context with the provided label exist, a new context will be created for you. Parameters: context_label ( str ) \u2013 name of existing or to be created context canvas ( Canvas ) \u2013 to be placed in context set_rounding_strategy(rules=DEFAULT_ROUNDING_STRATEGY) classmethod Set the global rounding strategy for dimensions. The rules are the same as for CanvasTemplate.round but are passed as a dictionary. Passing None to the rule argument will disable all rounding for dimensions. Default rules are: {'even': 'even', 'mode': 'round'} Available options: even \"whole\" = to nearest integer, \"even\" = to nearest even-numbered integer mode \"up\" = always round up, \"down\" = always round down \"round\" = standard rounding: >= +0.5 rounds up and < +0.5 rounds down Parameters: rules ( Union [ dict , None] , default: DEFAULT_ROUNDING_STRATEGY ) \u2013 will default to {'even': 'even', 'mode': 'round'} if rules is None","title":"FDL"},{"location":"Classes/fdl/#fdl","text":"The FDL class is meant to be an entry point and is a \"merge\" between a Header class and container class. The Header is created for you based on the arguments you provide at initialisation or you can pass a Header object as an attribute if you wish.","title":"FDL"},{"location":"Classes/fdl/#pyfdl.FDL","text":"Bases: Base","title":"FDL"},{"location":"Classes/fdl/#pyfdl.FDL.header","text":"Returns: Header ( Header ) \u2013 based on attributes","title":"header"},{"location":"Classes/fdl/#pyfdl.FDL.apply_defaults","text":"Applies default values defined in the defaults attribute to attributes that are None","title":"apply_defaults"},{"location":"Classes/fdl/#pyfdl.FDL.check_required","text":"Check that required attributes contain values. Checks linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set Returns: list \u2013 a list of missing attributes","title":"check_required"},{"location":"Classes/fdl/#pyfdl.FDL.validate","text":"Validate the current state of the FDL. ID's and relationships between items are checked and values are validated against the json schema. Raises: FDLValidationError \u2013 if any errors are found","title":"validate"},{"location":"Classes/fdl/#pyfdl.FDL.from_dict","text":"Create instances of classes from a provided dict. Parameters: raw ( dict ) \u2013 dictionary to convert to supported classes Returns: cls ( Any ) \u2013 and instance of the current class","title":"from_dict"},{"location":"Classes/fdl/#pyfdl.FDL.to_dict","text":"Produce a dictionary representation of the current object along with all sub objects. Raises: FDLError \u2013 if required keys are missing Returns: dict \u2013 representation of object","title":"to_dict"},{"location":"Classes/fdl/#pyfdl.FDL.load_schema","text":"Load a jsonschema based on the version in Header or default to current version set in base Returns: schema ( dict ) \u2013","title":"load_schema"},{"location":"Classes/fdl/#pyfdl.FDL.place_canvas_in_context","text":"Place a canvas in a context. If no context with the provided label exist, a new context will be created for you. Parameters: context_label ( str ) \u2013 name of existing or to be created context canvas ( Canvas ) \u2013 to be placed in context","title":"place_canvas_in_context"},{"location":"Classes/fdl/#pyfdl.FDL.set_rounding_strategy","text":"Set the global rounding strategy for dimensions. The rules are the same as for CanvasTemplate.round but are passed as a dictionary. Passing None to the rule argument will disable all rounding for dimensions. Default rules are: {'even': 'even', 'mode': 'round'} Available options: even \"whole\" = to nearest integer, \"even\" = to nearest even-numbered integer mode \"up\" = always round up, \"down\" = always round down \"round\" = standard rounding: >= +0.5 rounds up and < +0.5 rounds down Parameters: rules ( Union [ dict , None] , default: DEFAULT_ROUNDING_STRATEGY ) \u2013 will default to {'even': 'even', 'mode': 'round'} if rules is None","title":"set_rounding_strategy"},{"location":"Classes/framing_decision/","text":"Framing Decision pyfdl.FramingDecision(label=None, id_=None, framing_intent_id=None, dimensions=None, anchor_point=None, protection_dimensions=None, protection_anchor_point=None) Bases: Base adjust_anchor_point(canvas, h_method='center', v_method='center') Adjust this object's anchor_point either relative to protection_anchor_point or canvas.effective_anchor_point Please note that the h_method and v_method arguments only apply if no protection_anchor_point is present. Parameters: canvas ( Canvas ) \u2013 to fetch anchor point from in case protection_anchor_point is not set h_method ( str , default: 'center' ) \u2013 horizontal alignment ('left', 'center', 'right') v_method ( str , default: 'center' ) \u2013 vertical alignment ('top', 'center', 'bottom') adjust_protection_anchor_point(canvas, h_method='center', v_method='center') Adjust this object's protection_anchor_point if protection_dimensions are set. Please note that the h_method and v_method are primarily used when creating a canvas based on a canvas template Parameters: canvas ( Canvas ) \u2013 to fetch anchor point from in case protection_anchor_point is not set h_method ( str , default: 'center' ) \u2013 horizontal alignment ('left', 'center', 'right') v_method ( str , default: 'center' ) \u2013 vertical alignment ('top', 'center', 'bottom') from_framing_intent(canvas, framing_intent) classmethod Create a new FramingDecision based on the provided Canvas and FramingIntent The framing decision's properties are calculated for you. If the canvas has effective dimensions set, these will be used for the calculations. Otherwise, we use the dimensions Parameters: canvas ( Canvas ) \u2013 canvas to base framing decision on framing_intent ( FramingIntent ) \u2013 framing intent to place in canvas Returns: framing_decision ( FramingDecision ) \u2013","title":"Framing Decision"},{"location":"Classes/framing_decision/#framing-decision","text":"","title":"Framing Decision"},{"location":"Classes/framing_decision/#pyfdl.FramingDecision","text":"Bases: Base","title":"FramingDecision"},{"location":"Classes/framing_decision/#pyfdl.FramingDecision.adjust_anchor_point","text":"Adjust this object's anchor_point either relative to protection_anchor_point or canvas.effective_anchor_point Please note that the h_method and v_method arguments only apply if no protection_anchor_point is present. Parameters: canvas ( Canvas ) \u2013 to fetch anchor point from in case protection_anchor_point is not set h_method ( str , default: 'center' ) \u2013 horizontal alignment ('left', 'center', 'right') v_method ( str , default: 'center' ) \u2013 vertical alignment ('top', 'center', 'bottom')","title":"adjust_anchor_point"},{"location":"Classes/framing_decision/#pyfdl.FramingDecision.adjust_protection_anchor_point","text":"Adjust this object's protection_anchor_point if protection_dimensions are set. Please note that the h_method and v_method are primarily used when creating a canvas based on a canvas template Parameters: canvas ( Canvas ) \u2013 to fetch anchor point from in case protection_anchor_point is not set h_method ( str , default: 'center' ) \u2013 horizontal alignment ('left', 'center', 'right') v_method ( str , default: 'center' ) \u2013 vertical alignment ('top', 'center', 'bottom')","title":"adjust_protection_anchor_point"},{"location":"Classes/framing_decision/#pyfdl.FramingDecision.from_framing_intent","text":"Create a new FramingDecision based on the provided Canvas and FramingIntent The framing decision's properties are calculated for you. If the canvas has effective dimensions set, these will be used for the calculations. Otherwise, we use the dimensions Parameters: canvas ( Canvas ) \u2013 canvas to base framing decision on framing_intent ( FramingIntent ) \u2013 framing intent to place in canvas Returns: framing_decision ( FramingDecision ) \u2013","title":"from_framing_intent"},{"location":"Classes/framing_intent/","text":"Framing Intent pyfdl.FramingIntent(label=None, id_=None, aspect_ratio=None, protection=None) Bases: Base","title":"Framing Intent"},{"location":"Classes/framing_intent/#framing-intent","text":"","title":"Framing Intent"},{"location":"Classes/framing_intent/#pyfdl.FramingIntent","text":"Bases: Base","title":"FramingIntent"},{"location":"Classes/header/","text":"Header pyfdl.Header(_uuid=None, version=None, fdl_creator=None, default_framing_intent=None) Bases: Base","title":"Header"},{"location":"Classes/header/#header","text":"","title":"Header"},{"location":"Classes/header/#pyfdl.Header","text":"Bases: Base","title":"Header"}]}