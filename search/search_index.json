{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PyFDL Warning! PyFDL is still under development and parts of the API may still change. Please consider this before using it production. PyFDL is a toolkit to parse and produce Framing Decision List (FDL) files in python. In addition to parsing FDL files, PyFDL aims to provide an expandable command line tool and a set of plugins to scratch that FDL itch. PyFDL is modeled around the official FDL spec . Install Note! Until a package is available on PyPi, you'll need to install PyFDL manually. It's recommended to install packages like this in a virtual environment. pip install pyfdl Features Feature Read Write Notes FDL files \u2714 \u2714 Validate ID's and relationships \u2714 \u2714 Enforces unique ID's and makes sure relationship between items are valid Expandable through plugins \u2714 \u2714 Verify FDL with JSON Schema \u2714 \u2714 Commandline tool \u2716 \u2716 \u2714 Implemented \u2716 Not implemented N/A Not applicable","title":"Welcome to PyFDL"},{"location":"#welcome-to-pyfdl","text":"Warning! PyFDL is still under development and parts of the API may still change. Please consider this before using it production. PyFDL is a toolkit to parse and produce Framing Decision List (FDL) files in python. In addition to parsing FDL files, PyFDL aims to provide an expandable command line tool and a set of plugins to scratch that FDL itch. PyFDL is modeled around the official FDL spec .","title":"Welcome to PyFDL"},{"location":"#install","text":"Note! Until a package is available on PyPi, you'll need to install PyFDL manually. It's recommended to install packages like this in a virtual environment. pip install pyfdl","title":"Install"},{"location":"#features","text":"Feature Read Write Notes FDL files \u2714 \u2714 Validate ID's and relationships \u2714 \u2714 Enforces unique ID's and makes sure relationship between items are valid Expandable through plugins \u2714 \u2714 Verify FDL with JSON Schema \u2714 \u2714 Commandline tool \u2716 \u2716 \u2714 Implemented \u2716 Not implemented N/A Not applicable","title":"Features"},{"location":"contributions/","text":"Contributions Contributions come in many forms, be it reporting bugs, giving feedback or submitting code. It's all welcome as our goal is to provide a useful toolkit that suits the needs of its users. Response Time At the time of writing this, PyFDL is developed primarily in my spare time. Please excuse any delays in answering questions or reviewing of code. I'll do my best to respond as quickly as I can. Package Management PyFDL uses Hatch for package management. Please refer to their documentation for more info on usage. There is an environment setup for unit testing. hatch run test:test # or hatch test And a default shell for an interactive python session and so on. hatch shell To build and serve the documentation locally, you may use one of the following commands. # Only build the docs. You'll find them in the \"site\" folder hatch run docs:build # Serve the docs on localhost:8000 hatch run docs:serve Checklist For Contributions Fork the repo Please fork the repo on GitHub and clone your fork locally. git clone git@github.com:<USERNAME>/pyfdl.git Create a feature branch Always work in a feature branch. Do not submit Pull Requests directly from \"main\" Name your branch something relatable to the feature you're adding or a bug your fixing. Only address one feature/bug in a branch to the best of your judgement. git checkout -b my_feature_branch Write code Please try to follow the style of the project when writing code. Use type hints and provide docstrings in your code. Write unittests All contributions should provide tests for new/updated behavior. We use pytest , please consult their documentation for info on usage. New sample files may be added to the tests/sample_data folder if needed Documentation Please add/update relevant documentation. We use mkdocs and mkdocstrings NOTE! All python code blocks will get tested, so make sure to write valid examples. If you need to split your code blocks in the documentation, but would like to refer to each block, add your markdown file to the USE_MEM list in the tests/test_docs.py file Submitting a Pull Request Push your feature branch to your repo and open a Pull Request on GitHub. Branches on \"apetrynet's\" GitHub repo that get merged into \"main\" are deleted on GitHub to keep a clean repo. git push origin my_feature_branch Continue to push to this branch until the Pull Request is merged","title":"Contributions"},{"location":"contributions/#contributions","text":"Contributions come in many forms, be it reporting bugs, giving feedback or submitting code. It's all welcome as our goal is to provide a useful toolkit that suits the needs of its users.","title":"Contributions"},{"location":"contributions/#response-time","text":"At the time of writing this, PyFDL is developed primarily in my spare time. Please excuse any delays in answering questions or reviewing of code. I'll do my best to respond as quickly as I can.","title":"Response Time"},{"location":"contributions/#package-management","text":"PyFDL uses Hatch for package management. Please refer to their documentation for more info on usage. There is an environment setup for unit testing. hatch run test:test # or hatch test And a default shell for an interactive python session and so on. hatch shell To build and serve the documentation locally, you may use one of the following commands. # Only build the docs. You'll find them in the \"site\" folder hatch run docs:build # Serve the docs on localhost:8000 hatch run docs:serve","title":"Package Management"},{"location":"contributions/#checklist-for-contributions","text":"","title":"Checklist For Contributions"},{"location":"contributions/#fork-the-repo","text":"Please fork the repo on GitHub and clone your fork locally. git clone git@github.com:<USERNAME>/pyfdl.git","title":"Fork the repo"},{"location":"contributions/#create-a-feature-branch","text":"Always work in a feature branch. Do not submit Pull Requests directly from \"main\" Name your branch something relatable to the feature you're adding or a bug your fixing. Only address one feature/bug in a branch to the best of your judgement. git checkout -b my_feature_branch","title":"Create a feature branch"},{"location":"contributions/#write-code","text":"Please try to follow the style of the project when writing code. Use type hints and provide docstrings in your code.","title":"Write code"},{"location":"contributions/#write-unittests","text":"All contributions should provide tests for new/updated behavior. We use pytest , please consult their documentation for info on usage. New sample files may be added to the tests/sample_data folder if needed","title":"Write unittests"},{"location":"contributions/#documentation","text":"Please add/update relevant documentation. We use mkdocs and mkdocstrings NOTE! All python code blocks will get tested, so make sure to write valid examples. If you need to split your code blocks in the documentation, but would like to refer to each block, add your markdown file to the USE_MEM list in the tests/test_docs.py file","title":"Documentation"},{"location":"contributions/#submitting-a-pull-request","text":"Push your feature branch to your repo and open a Pull Request on GitHub. Branches on \"apetrynet's\" GitHub repo that get merged into \"main\" are deleted on GitHub to keep a clean repo. git push origin my_feature_branch Continue to push to this branch until the Pull Request is merged","title":"Submitting a Pull Request"},{"location":"getting_started/","text":"Getting Started About rounding As different parts of a pipeline requires different levels of precision we have an option to round values of dimensions accordingly. A canvas+framing decision for a \"raw\" camera canvas should in theory keep more precision than a canvas+framing decision for a conformed VFX plate. The rules for rounding strategy are the same as for CanvasTemplate.round The default strategy is to not apply rounding and keep float values where applicable, but this may be overridden by setting the rounding strategy via the set_rounding_strategy() function NOTE! The rounding strategy is set globally for where rounding applies except for CanvasTemplate.round which follows its own rules. Setting the global rounding strategy Here are a some examples of how to set the rounding strategy: import pyfdl # No rounding (default behavior) may either be set by passing the NO_ROUNDING variable pyfdl.set_rounding_strategy(pyfdl.NO_ROUNDING) # Or by explicitly passing None pyfdl.set_rounding_strategy(None) # For other requirements pass a dictionary with the rules pyfdl.set_rounding_strategy({'even': 'whole', 'mode': 'up'}) Usage Examples Create an FDL from scratch import pyfdl from pyfdl import Canvas, FramingIntent, Dimensions, Point from tempfile import NamedTemporaryFile fdl = pyfdl.FDL() # Applying defaults will provide you with a valid staring point fdl.apply_defaults() # Let's create a framing intent framing_intent = FramingIntent( label=\"1.78-1 Framing\", id_=\"FDLSMP03\", aspect_ratio=Dimensions(width=16, height=9), protection=0.088 ) # Add the newly created framing intent to our FDL fdl.framing_intents.add(framing_intent) # Now let's create a canvas canvas = Canvas( label=\"Open Gate RAW\", id_=\"20220310\", source_canvas_id=\"20220310\", dimensions=Dimensions(width=5184, height=4320), effective_dimensions=Dimensions(width=5184, height=4320), effective_anchor_point=Point(x=0, y=0), photosite_dimensions=Dimensions(5184, height=4320), physical_dimensions=Dimensions(width=25.92, height=21.60), anamorphic_squeeze=1.30 ) # Let's now add our canvas to the FDL within a context. # If no such context exists, one will be created for you. fdl.place_canvas_in_context(context_label=\"PanavisionDXL2\", canvas=canvas) # Finally, let's create a framing decision canvas.place_framing_intent(framing_intent=framing_intent) # Validate our FDL and save it with NamedTemporaryFile(suffix='.fdl', delete=False) as f: pyfdl.write_to_file(fdl, f.name, validate=True) Create a Canvas from a Canvas Template import pyfdl from pathlib import Path from tempfile import NamedTemporaryFile fdl_file = Path('tests/sample_data/Scenario-9__OriginalFDL_UsedToMakePlate.fdl') fdl = pyfdl.read_from_file(fdl_file) # Select the first canvas in the first context context = fdl.contexts[0] source_canvas = context.canvases[0] # Select the first canvas template canvas_template = fdl.canvas_templates[0] # We know we want to use the first framing decision of the source canvas, so we pass index 0 # You may also pass the actual `FramingDecision` source_canvas.framing_decisions[0] new_canvas = pyfdl.Canvas.from_canvas_template( canvas_template=canvas_template, source_canvas=source_canvas, source_framing_decision=0 ) # Place the new canvas along side the source fdl.place_canvas_in_context(context_label=context.label, canvas=new_canvas) # Validate and write to file. with NamedTemporaryFile(suffix='.fdl', delete=False) as f: pyfdl.write_to_file(fdl, f.name, validate=True)","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#about-rounding","text":"As different parts of a pipeline requires different levels of precision we have an option to round values of dimensions accordingly. A canvas+framing decision for a \"raw\" camera canvas should in theory keep more precision than a canvas+framing decision for a conformed VFX plate. The rules for rounding strategy are the same as for CanvasTemplate.round The default strategy is to not apply rounding and keep float values where applicable, but this may be overridden by setting the rounding strategy via the set_rounding_strategy() function NOTE! The rounding strategy is set globally for where rounding applies except for CanvasTemplate.round which follows its own rules.","title":"About rounding"},{"location":"getting_started/#setting-the-global-rounding-strategy","text":"Here are a some examples of how to set the rounding strategy: import pyfdl # No rounding (default behavior) may either be set by passing the NO_ROUNDING variable pyfdl.set_rounding_strategy(pyfdl.NO_ROUNDING) # Or by explicitly passing None pyfdl.set_rounding_strategy(None) # For other requirements pass a dictionary with the rules pyfdl.set_rounding_strategy({'even': 'whole', 'mode': 'up'})","title":"Setting the global rounding strategy"},{"location":"getting_started/#usage-examples","text":"","title":"Usage Examples"},{"location":"getting_started/#create-an-fdl-from-scratch","text":"import pyfdl from pyfdl import Canvas, FramingIntent, Dimensions, Point from tempfile import NamedTemporaryFile fdl = pyfdl.FDL() # Applying defaults will provide you with a valid staring point fdl.apply_defaults() # Let's create a framing intent framing_intent = FramingIntent( label=\"1.78-1 Framing\", id_=\"FDLSMP03\", aspect_ratio=Dimensions(width=16, height=9), protection=0.088 ) # Add the newly created framing intent to our FDL fdl.framing_intents.add(framing_intent) # Now let's create a canvas canvas = Canvas( label=\"Open Gate RAW\", id_=\"20220310\", source_canvas_id=\"20220310\", dimensions=Dimensions(width=5184, height=4320), effective_dimensions=Dimensions(width=5184, height=4320), effective_anchor_point=Point(x=0, y=0), photosite_dimensions=Dimensions(5184, height=4320), physical_dimensions=Dimensions(width=25.92, height=21.60), anamorphic_squeeze=1.30 ) # Let's now add our canvas to the FDL within a context. # If no such context exists, one will be created for you. fdl.place_canvas_in_context(context_label=\"PanavisionDXL2\", canvas=canvas) # Finally, let's create a framing decision canvas.place_framing_intent(framing_intent=framing_intent) # Validate our FDL and save it with NamedTemporaryFile(suffix='.fdl', delete=False) as f: pyfdl.write_to_file(fdl, f.name, validate=True)","title":"Create an FDL from scratch"},{"location":"getting_started/#create-a-canvas-from-a-canvas-template","text":"import pyfdl from pathlib import Path from tempfile import NamedTemporaryFile fdl_file = Path('tests/sample_data/Scenario-9__OriginalFDL_UsedToMakePlate.fdl') fdl = pyfdl.read_from_file(fdl_file) # Select the first canvas in the first context context = fdl.contexts[0] source_canvas = context.canvases[0] # Select the first canvas template canvas_template = fdl.canvas_templates[0] # We know we want to use the first framing decision of the source canvas, so we pass index 0 # You may also pass the actual `FramingDecision` source_canvas.framing_decisions[0] new_canvas = pyfdl.Canvas.from_canvas_template( canvas_template=canvas_template, source_canvas=source_canvas, source_framing_decision=0 ) # Place the new canvas along side the source fdl.place_canvas_in_context(context_label=context.label, canvas=new_canvas) # Validate and write to file. with NamedTemporaryFile(suffix='.fdl', delete=False) as f: pyfdl.write_to_file(fdl, f.name, validate=True)","title":"Create a Canvas from a Canvas Template"},{"location":"FDL%20Classes/canvas/","text":"Canvas pyfdl.Canvas(label=None, id_=None, source_canvas_id=None, dimensions=None, effective_dimensions=None, effective_anchor_point=None, photosite_dimensions=None, physical_dimensions=None, anamorphic_squeeze=None, framing_decisions=None) Bases: Base adjust_effective_anchor_point() Adjust the effective_anchor_point of this Canvas if effective_dimensions are set from_canvas_template(canvas_template, source_canvas, source_framing_decision=0) classmethod Create a new Canvas from the provided source_canvas and framing_decision based on a CanvasTemplate Parameters: canvas_template ( CanvasTemplate ) \u2013 describing how to handle incoming Canvas and FramingDecision source_canvas ( Canvas ) \u2013 to use as base for new canvas source_framing_decision ( Union [ FramingDecision , int ] , default: 0 ) \u2013 either a FramingDecision from the source canvas or the index ( int ) of one. Returns: canvas ( Canvas ) \u2013 based on the provided canvas template and sources get_dimensions() Get the most relevant dimensions and anchor point for the canvas. effective_dimensions and effective_anchor_point win over dimensions Returns: ( dimensions , anchor_point ) \u2013 place_framing_intent(framing_intent) Create a new FramingDecision based on the provided FramingIntent and add it to the collection of framing decisions. The framing decision's properties are calculated for you. If the canvas has effective dimensions set, these will be used for the calculations. Otherwise, we use the dimensions Parameters: framing_intent ( FramingIntent ) \u2013 framing intent to place in canvas Returns: framing_decision_id ( str ) \u2013 id of the newly created framing decision","title":"Canvas"},{"location":"FDL%20Classes/canvas/#canvas","text":"","title":"Canvas"},{"location":"FDL%20Classes/canvas/#pyfdl.Canvas","text":"Bases: Base","title":"Canvas"},{"location":"FDL%20Classes/canvas/#pyfdl.Canvas.adjust_effective_anchor_point","text":"Adjust the effective_anchor_point of this Canvas if effective_dimensions are set","title":"adjust_effective_anchor_point"},{"location":"FDL%20Classes/canvas/#pyfdl.Canvas.from_canvas_template","text":"Create a new Canvas from the provided source_canvas and framing_decision based on a CanvasTemplate Parameters: canvas_template ( CanvasTemplate ) \u2013 describing how to handle incoming Canvas and FramingDecision source_canvas ( Canvas ) \u2013 to use as base for new canvas source_framing_decision ( Union [ FramingDecision , int ] , default: 0 ) \u2013 either a FramingDecision from the source canvas or the index ( int ) of one. Returns: canvas ( Canvas ) \u2013 based on the provided canvas template and sources","title":"from_canvas_template"},{"location":"FDL%20Classes/canvas/#pyfdl.Canvas.get_dimensions","text":"Get the most relevant dimensions and anchor point for the canvas. effective_dimensions and effective_anchor_point win over dimensions Returns: ( dimensions , anchor_point ) \u2013","title":"get_dimensions"},{"location":"FDL%20Classes/canvas/#pyfdl.Canvas.place_framing_intent","text":"Create a new FramingDecision based on the provided FramingIntent and add it to the collection of framing decisions. The framing decision's properties are calculated for you. If the canvas has effective dimensions set, these will be used for the calculations. Otherwise, we use the dimensions Parameters: framing_intent ( FramingIntent ) \u2013 framing intent to place in canvas Returns: framing_decision_id ( str ) \u2013 id of the newly created framing decision","title":"place_framing_intent"},{"location":"FDL%20Classes/canvas_template/","text":"Canvas Template pyfdl.CanvasTemplate(label=None, id_=None, target_dimensions=None, target_anamorphic_squeeze=None, fit_source=None, fit_method=None, alignment_method_vertical=None, alignment_method_horizontal=None, preserve_from_source_canvas=None, maximum_dimensions=None, pad_to_maximum=None, round_=None) Bases: Base fit_source_to_target(source_dimensions, source_anamorphic_squeeze) Calculate the dimensions of fit_source inside target_dimensions based on fit_mode Parameters: source_dimensions ( Dimensions ) \u2013 source_anamorphic_squeeze ( float ) \u2013 Returns: size ( Dimensions ) \u2013 get_desqueezed_width(source_width, squeeze_factor) Get the de-squeezed width also considering the target_anamorphic_squeeze . Used to calculate scaling of canvases and framing decisions. If target_anamorphic_squeeze is 0, it's considered \"same as source\" and no de-squeeze is applied. Parameters: source_width ( Union [ float , int ] ) \u2013 from source Canvas or FramingDecision squeeze_factor ( float ) \u2013 source Canvas.anamorphic_squeeze Returns: width ( Union [ float , int ] ) \u2013 scaled to size get_scale_factor(source_dimensions, source_anamorphic_squeeze) Calculate the scale factor used when creating a new Canvas and FramingDecision Parameters: source_dimensions ( Dimensions ) \u2013 source_anamorphic_squeeze ( float ) \u2013 Returns: scale_factor ( float ) \u2013 get_transfer_keys() Get a list of attributes to transfer from source to destination in the order that preserves all attributes between fit_source and preserve_from_canvas Returns: keys ( List [ str ] ) \u2013","title":"Canvas Template"},{"location":"FDL%20Classes/canvas_template/#canvas-template","text":"","title":"Canvas Template"},{"location":"FDL%20Classes/canvas_template/#pyfdl.CanvasTemplate","text":"Bases: Base","title":"CanvasTemplate"},{"location":"FDL%20Classes/canvas_template/#pyfdl.CanvasTemplate.fit_source_to_target","text":"Calculate the dimensions of fit_source inside target_dimensions based on fit_mode Parameters: source_dimensions ( Dimensions ) \u2013 source_anamorphic_squeeze ( float ) \u2013 Returns: size ( Dimensions ) \u2013","title":"fit_source_to_target"},{"location":"FDL%20Classes/canvas_template/#pyfdl.CanvasTemplate.get_desqueezed_width","text":"Get the de-squeezed width also considering the target_anamorphic_squeeze . Used to calculate scaling of canvases and framing decisions. If target_anamorphic_squeeze is 0, it's considered \"same as source\" and no de-squeeze is applied. Parameters: source_width ( Union [ float , int ] ) \u2013 from source Canvas or FramingDecision squeeze_factor ( float ) \u2013 source Canvas.anamorphic_squeeze Returns: width ( Union [ float , int ] ) \u2013 scaled to size","title":"get_desqueezed_width"},{"location":"FDL%20Classes/canvas_template/#pyfdl.CanvasTemplate.get_scale_factor","text":"Calculate the scale factor used when creating a new Canvas and FramingDecision Parameters: source_dimensions ( Dimensions ) \u2013 source_anamorphic_squeeze ( float ) \u2013 Returns: scale_factor ( float ) \u2013","title":"get_scale_factor"},{"location":"FDL%20Classes/canvas_template/#pyfdl.CanvasTemplate.get_transfer_keys","text":"Get a list of attributes to transfer from source to destination in the order that preserves all attributes between fit_source and preserve_from_canvas Returns: keys ( List [ str ] ) \u2013","title":"get_transfer_keys"},{"location":"FDL%20Classes/common/","text":"Common Global Variables Version numbers are used as default values in Header and to select a matching json schema file if no version is set. pyfdl.FDL_SCHEMA_MAJOR = 1 module-attribute pyfdl.FDL_SCHEMA_MINOR = 0 module-attribute pyfdl.FDL_SCHEMA_VERSION = {'major': FDL_SCHEMA_MAJOR, 'minor': FDL_SCHEMA_MINOR} module-attribute Different workflows have different requirements for precision, so we are flexible in how to apply rounding of values pyfdl.DEFAULT_ROUNDING_STRATEGY = NO_ROUNDING module-attribute This is the default behavior for rounding the values of dimensions. The rules are the same as for CanvasTemplate.round . pyfdl.NO_ROUNDING = {} module-attribute This will disable rounding of values in dimensions. Exception being Canvas.dimensions when created by a canvas templates pyfdl.set_rounding_strategy(rules) pyfdl.rounding_strategy() Base Classes Below is a collection of the common classes that are used by other classes. pyfdl.Base() Base class not to be instanced directly. Attributes: attributes \u2013 list of attributes described in FDL spec kwarg_map \u2013 map attribute names that clash with reserved builtin python functions to safe alternatives like: (id -> id_) and (uuid -> uuid_) object_map \u2013 map attributes to custom classes required \u2013 list of required attributes. Supports linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set defaults \u2013 map default values to attributes. In addition to primitive values supports: callable, subclasses of Base apply_defaults() Applies default values defined in the defaults attribute to attributes that are None check_required() Check that required attributes contain values. Checks linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set Returns: list \u2013 a list of missing attributes from_dict(raw) classmethod Create instances of classes from a provided dict. Parameters: raw ( dict ) \u2013 dictionary to convert to supported classes Returns: cls ( Any ) \u2013 and instance of the current class to_dict() Produce a dictionary representation of the current object along with all sub objects. Raises: FDLError \u2013 if required keys are missing Returns: dict \u2013 representation of object pyfdl.TypedCollection(cls) Collection only accepting items of a given class. In addition, a strict control of unique id's is enforced. Parameters: cls ( Any ) \u2013 type of class to be accepted add(item) Add an item to the collection. All items added to a collection get associated to the collection by passing itself as parent Parameters: item ( Any ) \u2013 of type passed at instancing of the collection. Raises: FDLError \u2013 for missing id or if a duplicate id is detected get(item_id) Get an item in the collection Parameters: item_id ( str ) \u2013 id of item you'd like to get Returns: item ( Union [ Any , None] ) \u2013 in collection or None if not found remove(item_id) Remove an item in the collection if found Parameters: item_id ( str ) \u2013 id of item to be removed pyfdl.Dimensions(width, height, dtype=float) Bases: Base Dimensions may be either ints or floats . You may pass the desired data type at instantiation. However, the objects using the dimensions will set the required type for you when they are passed to them Parameters: width ( Union [ int , float ] ) \u2013 height ( Union [ int , float ] ) \u2013 dtype ( Union [ Type [ int ], Type [ float ]] , default: float ) \u2013 set data type of dimension values, mostly used behind the scenes. copy() Create a copy of these dimensions Returns: copy ( Dimensions ) \u2013 of these dimensions scale_by(factor) Scale the dimensions by the provider factor Parameters: factor ( float ) \u2013 pyfdl.Point(x, y) Bases: Base Point properly formatted Parameters: x ( float ) \u2013 y ( float ) \u2013 pyfdl.RoundStrategy(even=None, mode=None) Bases: Base Describes how to handle rounding canvas dimensions when applying a CanvasTemplate . Parameters: even ( str , default: None ) \u2013 \"whole\" = to nearest integer, \"even\" = to nearest even-numbered integer mode ( str , default: None ) \u2013 \"up\" = always round up, \"down\" = always round down \"round\" = standard rounding, >= +0.5 rounds up,< +0.5 rounds down Raises: FDLError \u2013 if you provide a value other than the ones listed above round_dimensions(dimensions) Round the provided dimensions based on the rules defined in this object Parameters: dimensions ( Dimensions ) \u2013 Returns: dimensions ( Dimensions ) \u2013 rounded based on rules","title":"Common"},{"location":"FDL%20Classes/common/#common","text":"","title":"Common"},{"location":"FDL%20Classes/common/#global-variables","text":"Version numbers are used as default values in Header and to select a matching json schema file if no version is set.","title":"Global Variables"},{"location":"FDL%20Classes/common/#pyfdl.FDL_SCHEMA_MAJOR","text":"","title":"FDL_SCHEMA_MAJOR"},{"location":"FDL%20Classes/common/#pyfdl.FDL_SCHEMA_MINOR","text":"","title":"FDL_SCHEMA_MINOR"},{"location":"FDL%20Classes/common/#pyfdl.FDL_SCHEMA_VERSION","text":"Different workflows have different requirements for precision, so we are flexible in how to apply rounding of values","title":"FDL_SCHEMA_VERSION"},{"location":"FDL%20Classes/common/#pyfdl.DEFAULT_ROUNDING_STRATEGY","text":"This is the default behavior for rounding the values of dimensions. The rules are the same as for CanvasTemplate.round .","title":"DEFAULT_ROUNDING_STRATEGY"},{"location":"FDL%20Classes/common/#pyfdl.NO_ROUNDING","text":"This will disable rounding of values in dimensions. Exception being Canvas.dimensions when created by a canvas templates","title":"NO_ROUNDING"},{"location":"FDL%20Classes/common/#pyfdl.set_rounding_strategy","text":"","title":"set_rounding_strategy"},{"location":"FDL%20Classes/common/#pyfdl.rounding_strategy","text":"","title":"rounding_strategy"},{"location":"FDL%20Classes/common/#base-classes","text":"Below is a collection of the common classes that are used by other classes.","title":"Base Classes"},{"location":"FDL%20Classes/common/#pyfdl.Base","text":"Base class not to be instanced directly. Attributes: attributes \u2013 list of attributes described in FDL spec kwarg_map \u2013 map attribute names that clash with reserved builtin python functions to safe alternatives like: (id -> id_) and (uuid -> uuid_) object_map \u2013 map attributes to custom classes required \u2013 list of required attributes. Supports linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set defaults \u2013 map default values to attributes. In addition to primitive values supports: callable, subclasses of Base","title":"Base"},{"location":"FDL%20Classes/common/#pyfdl.Base.apply_defaults","text":"Applies default values defined in the defaults attribute to attributes that are None","title":"apply_defaults"},{"location":"FDL%20Classes/common/#pyfdl.Base.check_required","text":"Check that required attributes contain values. Checks linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set Returns: list \u2013 a list of missing attributes","title":"check_required"},{"location":"FDL%20Classes/common/#pyfdl.Base.from_dict","text":"Create instances of classes from a provided dict. Parameters: raw ( dict ) \u2013 dictionary to convert to supported classes Returns: cls ( Any ) \u2013 and instance of the current class","title":"from_dict"},{"location":"FDL%20Classes/common/#pyfdl.Base.to_dict","text":"Produce a dictionary representation of the current object along with all sub objects. Raises: FDLError \u2013 if required keys are missing Returns: dict \u2013 representation of object","title":"to_dict"},{"location":"FDL%20Classes/common/#pyfdl.TypedCollection","text":"Collection only accepting items of a given class. In addition, a strict control of unique id's is enforced. Parameters: cls ( Any ) \u2013 type of class to be accepted","title":"TypedCollection"},{"location":"FDL%20Classes/common/#pyfdl.TypedCollection.add","text":"Add an item to the collection. All items added to a collection get associated to the collection by passing itself as parent Parameters: item ( Any ) \u2013 of type passed at instancing of the collection. Raises: FDLError \u2013 for missing id or if a duplicate id is detected","title":"add"},{"location":"FDL%20Classes/common/#pyfdl.TypedCollection.get","text":"Get an item in the collection Parameters: item_id ( str ) \u2013 id of item you'd like to get Returns: item ( Union [ Any , None] ) \u2013 in collection or None if not found","title":"get"},{"location":"FDL%20Classes/common/#pyfdl.TypedCollection.remove","text":"Remove an item in the collection if found Parameters: item_id ( str ) \u2013 id of item to be removed","title":"remove"},{"location":"FDL%20Classes/common/#pyfdl.Dimensions","text":"Bases: Base Dimensions may be either ints or floats . You may pass the desired data type at instantiation. However, the objects using the dimensions will set the required type for you when they are passed to them Parameters: width ( Union [ int , float ] ) \u2013 height ( Union [ int , float ] ) \u2013 dtype ( Union [ Type [ int ], Type [ float ]] , default: float ) \u2013 set data type of dimension values, mostly used behind the scenes.","title":"Dimensions"},{"location":"FDL%20Classes/common/#pyfdl.Dimensions.copy","text":"Create a copy of these dimensions Returns: copy ( Dimensions ) \u2013 of these dimensions","title":"copy"},{"location":"FDL%20Classes/common/#pyfdl.Dimensions.scale_by","text":"Scale the dimensions by the provider factor Parameters: factor ( float ) \u2013","title":"scale_by"},{"location":"FDL%20Classes/common/#pyfdl.Point","text":"Bases: Base Point properly formatted Parameters: x ( float ) \u2013 y ( float ) \u2013","title":"Point"},{"location":"FDL%20Classes/common/#pyfdl.RoundStrategy","text":"Bases: Base Describes how to handle rounding canvas dimensions when applying a CanvasTemplate . Parameters: even ( str , default: None ) \u2013 \"whole\" = to nearest integer, \"even\" = to nearest even-numbered integer mode ( str , default: None ) \u2013 \"up\" = always round up, \"down\" = always round down \"round\" = standard rounding, >= +0.5 rounds up,< +0.5 rounds down Raises: FDLError \u2013 if you provide a value other than the ones listed above","title":"RoundStrategy"},{"location":"FDL%20Classes/common/#pyfdl.RoundStrategy.round_dimensions","text":"Round the provided dimensions based on the rules defined in this object Parameters: dimensions ( Dimensions ) \u2013 Returns: dimensions ( Dimensions ) \u2013 rounded based on rules","title":"round_dimensions"},{"location":"FDL%20Classes/context/","text":"Context pyfdl.Context(label=None, context_creator=None, canvases=None) Bases: Base","title":"Context"},{"location":"FDL%20Classes/context/#context","text":"","title":"Context"},{"location":"FDL%20Classes/context/#pyfdl.Context","text":"Bases: Base","title":"Context"},{"location":"FDL%20Classes/errors/","text":"Errors pyfdl.FDLError Bases: Exception","title":"Errors"},{"location":"FDL%20Classes/errors/#errors","text":"","title":"Errors"},{"location":"FDL%20Classes/errors/#pyfdl.FDLError","text":"Bases: Exception","title":"FDLError"},{"location":"FDL%20Classes/fdl/","text":"FDL The FDL class is meant to be an entry point and is a \"merge\" between a Header class and container class. The Header is created for you based on the arguments you provide at initialisation or you can pass a Header object as an attribute if you wish. pyfdl.FDL(uuid_=None, version=None, fdl_creator=None, default_framing_intent=None, framing_intents=None, contexts=None, canvas_templates=None) Bases: Base header: Header property writable Returns: Header ( Header ) \u2013 based on attributes apply_defaults() Applies default values defined in the defaults attribute to attributes that are None check_required() Check that required attributes contain values. Checks linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set Returns: list \u2013 a list of missing attributes validate() Validate the current state of the FDL. ID's and relationships between items are checked and values are validated against the json schema. Raises: FDLValidationError \u2013 if any errors are found from_dict(raw) classmethod Create instances of classes from a provided dict. Parameters: raw ( dict ) \u2013 dictionary to convert to supported classes Returns: cls ( Any ) \u2013 and instance of the current class to_dict() Produce a dictionary representation of the current object along with all sub objects. Raises: FDLError \u2013 if required keys are missing Returns: dict \u2013 representation of object load_schema() Load a jsonschema based on the version in Header or default to current version set in base Returns: schema ( dict ) \u2013 place_canvas_in_context(context_label, canvas) Place a canvas in a context. If no context with the provided label exist, a new context will be created for you. Parameters: context_label ( str ) \u2013 name of existing or to be created context canvas ( Canvas ) \u2013 to be placed in context","title":"FDL"},{"location":"FDL%20Classes/fdl/#fdl","text":"The FDL class is meant to be an entry point and is a \"merge\" between a Header class and container class. The Header is created for you based on the arguments you provide at initialisation or you can pass a Header object as an attribute if you wish.","title":"FDL"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL","text":"Bases: Base","title":"FDL"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL.header","text":"Returns: Header ( Header ) \u2013 based on attributes","title":"header"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL.apply_defaults","text":"Applies default values defined in the defaults attribute to attributes that are None","title":"apply_defaults"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL.check_required","text":"Check that required attributes contain values. Checks linked attributes like: \"effective_dimensions.effective_anchor_point\" where \"effective_anchor_point\" is required if \"effective_dimensions\" is set Returns: list \u2013 a list of missing attributes","title":"check_required"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL.validate","text":"Validate the current state of the FDL. ID's and relationships between items are checked and values are validated against the json schema. Raises: FDLValidationError \u2013 if any errors are found","title":"validate"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL.from_dict","text":"Create instances of classes from a provided dict. Parameters: raw ( dict ) \u2013 dictionary to convert to supported classes Returns: cls ( Any ) \u2013 and instance of the current class","title":"from_dict"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL.to_dict","text":"Produce a dictionary representation of the current object along with all sub objects. Raises: FDLError \u2013 if required keys are missing Returns: dict \u2013 representation of object","title":"to_dict"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL.load_schema","text":"Load a jsonschema based on the version in Header or default to current version set in base Returns: schema ( dict ) \u2013","title":"load_schema"},{"location":"FDL%20Classes/fdl/#pyfdl.FDL.place_canvas_in_context","text":"Place a canvas in a context. If no context with the provided label exist, a new context will be created for you. Parameters: context_label ( str ) \u2013 name of existing or to be created context canvas ( Canvas ) \u2013 to be placed in context","title":"place_canvas_in_context"},{"location":"FDL%20Classes/framing_decision/","text":"Framing Decision pyfdl.FramingDecision(label=None, id_=None, framing_intent_id=None, dimensions=None, anchor_point=None, protection_dimensions=None, protection_anchor_point=None) Bases: Base adjust_anchor_point(canvas, h_method='center', v_method='center') Adjust this object's anchor_point either relative to protection_anchor_point or canvas.effective_anchor_point Please note that the h_method and v_method arguments only apply if no protection_anchor_point is present. Parameters: canvas ( Canvas ) \u2013 to fetch anchor point from in case protection_anchor_point is not set h_method ( str , default: 'center' ) \u2013 horizontal alignment ('left', 'center', 'right') v_method ( str , default: 'center' ) \u2013 vertical alignment ('top', 'center', 'bottom') adjust_protection_anchor_point(canvas, h_method='center', v_method='center') Adjust this object's protection_anchor_point if protection_dimensions are set. Please note that the h_method and v_method are primarily used when creating a canvas based on a canvas template Parameters: canvas ( Canvas ) \u2013 to fetch anchor point from in case protection_anchor_point is not set h_method ( str , default: 'center' ) \u2013 horizontal alignment ('left', 'center', 'right') v_method ( str , default: 'center' ) \u2013 vertical alignment ('top', 'center', 'bottom') from_framing_intent(canvas, framing_intent) classmethod Create a new FramingDecision based on the provided Canvas and FramingIntent The framing decision's properties are calculated for you. If the canvas has effective dimensions set, these will be used for the calculations. Otherwise, we use the dimensions Parameters: canvas ( Canvas ) \u2013 canvas to base framing decision on framing_intent ( FramingIntent ) \u2013 framing intent to place in canvas Returns: framing_decision ( FramingDecision ) \u2013","title":"Framing Decision"},{"location":"FDL%20Classes/framing_decision/#framing-decision","text":"","title":"Framing Decision"},{"location":"FDL%20Classes/framing_decision/#pyfdl.FramingDecision","text":"Bases: Base","title":"FramingDecision"},{"location":"FDL%20Classes/framing_decision/#pyfdl.FramingDecision.adjust_anchor_point","text":"Adjust this object's anchor_point either relative to protection_anchor_point or canvas.effective_anchor_point Please note that the h_method and v_method arguments only apply if no protection_anchor_point is present. Parameters: canvas ( Canvas ) \u2013 to fetch anchor point from in case protection_anchor_point is not set h_method ( str , default: 'center' ) \u2013 horizontal alignment ('left', 'center', 'right') v_method ( str , default: 'center' ) \u2013 vertical alignment ('top', 'center', 'bottom')","title":"adjust_anchor_point"},{"location":"FDL%20Classes/framing_decision/#pyfdl.FramingDecision.adjust_protection_anchor_point","text":"Adjust this object's protection_anchor_point if protection_dimensions are set. Please note that the h_method and v_method are primarily used when creating a canvas based on a canvas template Parameters: canvas ( Canvas ) \u2013 to fetch anchor point from in case protection_anchor_point is not set h_method ( str , default: 'center' ) \u2013 horizontal alignment ('left', 'center', 'right') v_method ( str , default: 'center' ) \u2013 vertical alignment ('top', 'center', 'bottom')","title":"adjust_protection_anchor_point"},{"location":"FDL%20Classes/framing_decision/#pyfdl.FramingDecision.from_framing_intent","text":"Create a new FramingDecision based on the provided Canvas and FramingIntent The framing decision's properties are calculated for you. If the canvas has effective dimensions set, these will be used for the calculations. Otherwise, we use the dimensions Parameters: canvas ( Canvas ) \u2013 canvas to base framing decision on framing_intent ( FramingIntent ) \u2013 framing intent to place in canvas Returns: framing_decision ( FramingDecision ) \u2013","title":"from_framing_intent"},{"location":"FDL%20Classes/framing_intent/","text":"Framing Intent pyfdl.FramingIntent(label=None, id_=None, aspect_ratio=None, protection=None) Bases: Base","title":"Framing Intent"},{"location":"FDL%20Classes/framing_intent/#framing-intent","text":"","title":"Framing Intent"},{"location":"FDL%20Classes/framing_intent/#pyfdl.FramingIntent","text":"Bases: Base","title":"FramingIntent"},{"location":"FDL%20Classes/header/","text":"Header pyfdl.Header(uuid_=None, version=None, fdl_creator=None, default_framing_intent=None) Bases: Base","title":"Header"},{"location":"FDL%20Classes/header/#header","text":"","title":"Header"},{"location":"FDL%20Classes/header/#pyfdl.Header","text":"Bases: Base","title":"Header"},{"location":"Handlers/handlers/","text":"Handlers PyFDL provides a set of functions to read and write files. These functions will pick the appropriate handler based on path.suffix or handler name. pyfdl.read_from_file(path, handler_name=None, **handler_kwargs) Handler agnostic function for producing an FDL from a file. A suitable handler will be chosen based on path or handler_name . Parameters: path ( Union [ Path , str ] ) \u2013 to the file in question handler_name ( str , default: None ) \u2013 name of handler to use **handler_kwargs ( Optional [ Any ] , default: {} ) \u2013 arguments passed to handler Returns: FDL ( FDL ) \u2013 pyfdl.read_from_string(s, handler_name='fdl', **handler_kwargs) Handler agnostic function for producing an FDL based on a string. A suitable handler will be chosen based on handler_name . Defaults to \"fdl\". Parameters: s ( str ) \u2013 string to convert into an FDL handler_name ( str , default: 'fdl' ) \u2013 name of handler to use **handler_kwargs ( Optional [ Any ] , default: {} ) \u2013 arguments passed to handler Returns: FDL ( FDL ) \u2013 pyfdl.write_to_file(fdl, path, handler_name=None, **handler_kwargs) Handler agnostic function to write a file based on an FDL. A suitable handler will be chosen based on path or handler_name Parameters: fdl ( FDL ) \u2013 to write path ( Union [ Path , str ] ) \u2013 to file handler_name ( str , default: None ) \u2013 name of handler to use **handler_kwargs ( Optional [ Any ] , default: {} ) \u2013 arguments passed to handler pyfdl.write_to_string(fdl, handler_name='fdl', **handler_kwargs) Handler agnostic function for producing a string representation of an FDL. A suitable handler will be chosen based on handler_name . Parameters: fdl ( FDL ) \u2013 to write handler_name ( str , default: 'fdl' ) \u2013 name of hanlder to use **handler_kwargs ( Optional [ Any ] , default: {} ) \u2013 arguments passed to handler Returns: FDLHandler This is the built-in handler for reading and writing fdl files. No need to call this directly. Use the functions above. pyfdl.handlers.fdl_handler FDLHandler() The default built-in FDL handler. Takes care of reading and writing FDL files read_from_file(path, validate=True) Read an FDL from a file. Parameters: path ( Path ) \u2013 to fdl file validate ( bool , default: True ) \u2013 validate incoming json with jsonschema Raises: ValidationError \u2013 if the contents doesn't follow the spec Returns: FDL ( FDL ) \u2013 read_from_string(s, validate=True) Read an FDL from a string. Parameters: s ( str ) \u2013 string representation of an FDL validate ( bool , default: True ) \u2013 validate incoming json with jsonschema Raises: ValidationError \u2013 if the contents doesn't follow the spec Returns: FDL ( FDL ) \u2013 write_to_file(fdl, path, validate=True, indent=2) Dump an FDL to a file. Parameters: fdl ( FDL ) \u2013 object to serialize path ( Path ) \u2013 path to store fdl file validate ( bool , default: True ) \u2013 validate outgoing json with jsonschema indent ( Union [ int , None] , default: 2 ) \u2013 amount of spaces Raises: ValidationError \u2013 if the contents doesn't follow the spec write_to_string(fdl, validate=True, indent=2) Dump an FDL to string Parameters: fdl ( FDL ) \u2013 object to serialize validate ( bool , default: True ) \u2013 validate outgoing json with jsonschema indent ( Union [ int , None] , default: 2 ) \u2013 amount of spaces Raises: ValidationError \u2013 if the contents doesn't follow the spec Returns: string ( str ) \u2013 representation of the resulting json register_plugin(registry) Mandatory function to register handler in the registry. Called by the PluginRegistry itself. Parameters: registry ( PluginReistry ) \u2013 The PluginRegistry passes itself to this function","title":"Handlers"},{"location":"Handlers/handlers/#handlers","text":"PyFDL provides a set of functions to read and write files. These functions will pick the appropriate handler based on path.suffix or handler name.","title":"Handlers"},{"location":"Handlers/handlers/#pyfdl.read_from_file","text":"Handler agnostic function for producing an FDL from a file. A suitable handler will be chosen based on path or handler_name . Parameters: path ( Union [ Path , str ] ) \u2013 to the file in question handler_name ( str , default: None ) \u2013 name of handler to use **handler_kwargs ( Optional [ Any ] , default: {} ) \u2013 arguments passed to handler Returns: FDL ( FDL ) \u2013","title":"read_from_file"},{"location":"Handlers/handlers/#pyfdl.read_from_string","text":"Handler agnostic function for producing an FDL based on a string. A suitable handler will be chosen based on handler_name . Defaults to \"fdl\". Parameters: s ( str ) \u2013 string to convert into an FDL handler_name ( str , default: 'fdl' ) \u2013 name of handler to use **handler_kwargs ( Optional [ Any ] , default: {} ) \u2013 arguments passed to handler Returns: FDL ( FDL ) \u2013","title":"read_from_string"},{"location":"Handlers/handlers/#pyfdl.write_to_file","text":"Handler agnostic function to write a file based on an FDL. A suitable handler will be chosen based on path or handler_name Parameters: fdl ( FDL ) \u2013 to write path ( Union [ Path , str ] ) \u2013 to file handler_name ( str , default: None ) \u2013 name of handler to use **handler_kwargs ( Optional [ Any ] , default: {} ) \u2013 arguments passed to handler","title":"write_to_file"},{"location":"Handlers/handlers/#pyfdl.write_to_string","text":"Handler agnostic function for producing a string representation of an FDL. A suitable handler will be chosen based on handler_name . Parameters: fdl ( FDL ) \u2013 to write handler_name ( str , default: 'fdl' ) \u2013 name of hanlder to use **handler_kwargs ( Optional [ Any ] , default: {} ) \u2013 arguments passed to handler Returns:","title":"write_to_string"},{"location":"Handlers/handlers/#fdlhandler","text":"This is the built-in handler for reading and writing fdl files. No need to call this directly. Use the functions above.","title":"FDLHandler"},{"location":"Handlers/handlers/#pyfdl.handlers.fdl_handler","text":"","title":"fdl_handler"},{"location":"Handlers/handlers/#pyfdl.handlers.fdl_handler.FDLHandler","text":"The default built-in FDL handler. Takes care of reading and writing FDL files","title":"FDLHandler"},{"location":"Handlers/handlers/#pyfdl.handlers.fdl_handler.FDLHandler.read_from_file","text":"Read an FDL from a file. Parameters: path ( Path ) \u2013 to fdl file validate ( bool , default: True ) \u2013 validate incoming json with jsonschema Raises: ValidationError \u2013 if the contents doesn't follow the spec Returns: FDL ( FDL ) \u2013","title":"read_from_file"},{"location":"Handlers/handlers/#pyfdl.handlers.fdl_handler.FDLHandler.read_from_string","text":"Read an FDL from a string. Parameters: s ( str ) \u2013 string representation of an FDL validate ( bool , default: True ) \u2013 validate incoming json with jsonschema Raises: ValidationError \u2013 if the contents doesn't follow the spec Returns: FDL ( FDL ) \u2013","title":"read_from_string"},{"location":"Handlers/handlers/#pyfdl.handlers.fdl_handler.FDLHandler.write_to_file","text":"Dump an FDL to a file. Parameters: fdl ( FDL ) \u2013 object to serialize path ( Path ) \u2013 path to store fdl file validate ( bool , default: True ) \u2013 validate outgoing json with jsonschema indent ( Union [ int , None] , default: 2 ) \u2013 amount of spaces Raises: ValidationError \u2013 if the contents doesn't follow the spec","title":"write_to_file"},{"location":"Handlers/handlers/#pyfdl.handlers.fdl_handler.FDLHandler.write_to_string","text":"Dump an FDL to string Parameters: fdl ( FDL ) \u2013 object to serialize validate ( bool , default: True ) \u2013 validate outgoing json with jsonschema indent ( Union [ int , None] , default: 2 ) \u2013 amount of spaces Raises: ValidationError \u2013 if the contents doesn't follow the spec Returns: string ( str ) \u2013 representation of the resulting json","title":"write_to_string"},{"location":"Handlers/handlers/#pyfdl.handlers.fdl_handler.register_plugin","text":"Mandatory function to register handler in the registry. Called by the PluginRegistry itself. Parameters: registry ( PluginReistry ) \u2013 The PluginRegistry passes itself to this function","title":"register_plugin"},{"location":"Plugins/plugins/","text":"About Plugins PyFDL supports plugins for expanding the toolkit. This may be useful to add support for converting frame line definitions in another formats to FDL or reading metadata from files to mention a few examples. Plugin types Handlers Plugins that take care of reading/writing files to and/or from FDL are called handlers . PyFDL comes with a built-in FDLHandler which takes care of reading and writing FDL files. Writing a handler plugin There are only a couple of requirements for a handler. The handler needs to be a class with a name variable. If your handler deals with files you should provide a suffixes variable containing a list of suffixes to support. Suffixes include the dot like. \".yml\" The module needs to provide a function, example: register_plugin(registry) which accepts one argument for the registry. This function will call registry.add_handler(<HANDLER_INSTANCE>) with an instance of your handler. Example of a YAML Handler: import yaml from pathlib import Path from typing import Optional, Any from pyfdl import FDL class YAMLHandler: def __init__(self): # Name is required self.name = 'yaml' # Suffixes may be used to automagically select this handler based on path self.suffixes = [\".yml\", \".yaml\"] def write_to_string(self, fdl: FDL, validate: bool = True, **yaml_args: Optional[Any]) -> str: if validate: fdl.validate() return yaml.dump(fdl.to_dict(), **yaml_args) def write_to_file(self, fdl: FDL, path: Path, validate: bool = True, **yaml_args: Optional[Any]) -> str: if validate: fdl.validate() print('yoho') with path.open('w') as f: f.write(yaml.dump(fdl.to_dict(), **yaml_args)) def custom_method(self, fdl: FDL, brand: str) -> FDL: fdl.fdl_creator = brand return fdl def register_plugin(registry: 'PluginRegistry'): registry.add_handler(YAMLHandler()) Installing a plugin Install via pip Ideally you package your plugin according to best practices and share it via PyPi for other to use. However, the only requirement from PyFDL's perspective is that you install the plugin to PyFDL's plugin namespace: pyfdl.plugins . In your pyproject.toml or setup.py make sure to add your package/module like so: [project.entry-points.\"pyfdl.plugins\"] # If you choose to call your register function something else, make sure to adjust the entry below. yaml_handler = \"yaml_handler:register_plugin\" You are free to name your register function whatever you like, but make sure you add it after the module name. If you don't provide a function name PyFDL will assume the function is named register_plugin and will ignore your plugin if that is not the case. Install at runtime You may also add your handler directly in your code. To do this, simply get a hold of the registry and add your handler. from pyfdl.plugins import get_registry registry = get_registry() registry.add_handler(YAMLHandler()) Using your handler If your handler provides one or more of the following methods: read_from_file read_from_string , write_to_file or write_to_string , PyFDL will choose your handler based on either path (suffix) or directly asking for this specific handler. import pyfdl from pathlib import Path from tempfile import NamedTemporaryFile fdl = pyfdl.FDL() fdl.apply_defaults() pyfdl.write_to_string(fdl, handler_name='yaml', indent=4) pyfdl.write_to_file(fdl, path=NamedTemporaryFile(suffix='.yml', delete=False).name) If your handler doesn't provide one of the methods above or you have others exposed you can use them like so: from pyfdl.handlers import get_handler my_handler = get_handler(func_name='custom_method', handler_name='yaml') fdl = FDL() fdl.apply_defaults() assert fdl.fdl_creator == 'PyFDL' my_handler.custom_method(fdl, \"my brand\") assert fdl.fdl_creator == 'my brand'","title":"About Plugins"},{"location":"Plugins/plugins/#about-plugins","text":"PyFDL supports plugins for expanding the toolkit. This may be useful to add support for converting frame line definitions in another formats to FDL or reading metadata from files to mention a few examples.","title":"About Plugins"},{"location":"Plugins/plugins/#plugin-types","text":"","title":"Plugin types"},{"location":"Plugins/plugins/#handlers","text":"Plugins that take care of reading/writing files to and/or from FDL are called handlers . PyFDL comes with a built-in FDLHandler which takes care of reading and writing FDL files.","title":"Handlers"},{"location":"Plugins/plugins/#writing-a-handler-plugin","text":"There are only a couple of requirements for a handler. The handler needs to be a class with a name variable. If your handler deals with files you should provide a suffixes variable containing a list of suffixes to support. Suffixes include the dot like. \".yml\" The module needs to provide a function, example: register_plugin(registry) which accepts one argument for the registry. This function will call registry.add_handler(<HANDLER_INSTANCE>) with an instance of your handler. Example of a YAML Handler: import yaml from pathlib import Path from typing import Optional, Any from pyfdl import FDL class YAMLHandler: def __init__(self): # Name is required self.name = 'yaml' # Suffixes may be used to automagically select this handler based on path self.suffixes = [\".yml\", \".yaml\"] def write_to_string(self, fdl: FDL, validate: bool = True, **yaml_args: Optional[Any]) -> str: if validate: fdl.validate() return yaml.dump(fdl.to_dict(), **yaml_args) def write_to_file(self, fdl: FDL, path: Path, validate: bool = True, **yaml_args: Optional[Any]) -> str: if validate: fdl.validate() print('yoho') with path.open('w') as f: f.write(yaml.dump(fdl.to_dict(), **yaml_args)) def custom_method(self, fdl: FDL, brand: str) -> FDL: fdl.fdl_creator = brand return fdl def register_plugin(registry: 'PluginRegistry'): registry.add_handler(YAMLHandler())","title":"Writing a handler plugin"},{"location":"Plugins/plugins/#installing-a-plugin","text":"","title":"Installing a plugin"},{"location":"Plugins/plugins/#install-via-pip","text":"Ideally you package your plugin according to best practices and share it via PyPi for other to use. However, the only requirement from PyFDL's perspective is that you install the plugin to PyFDL's plugin namespace: pyfdl.plugins . In your pyproject.toml or setup.py make sure to add your package/module like so: [project.entry-points.\"pyfdl.plugins\"] # If you choose to call your register function something else, make sure to adjust the entry below. yaml_handler = \"yaml_handler:register_plugin\" You are free to name your register function whatever you like, but make sure you add it after the module name. If you don't provide a function name PyFDL will assume the function is named register_plugin and will ignore your plugin if that is not the case.","title":"Install via pip"},{"location":"Plugins/plugins/#install-at-runtime","text":"You may also add your handler directly in your code. To do this, simply get a hold of the registry and add your handler. from pyfdl.plugins import get_registry registry = get_registry() registry.add_handler(YAMLHandler())","title":"Install at runtime"},{"location":"Plugins/plugins/#using-your-handler","text":"If your handler provides one or more of the following methods: read_from_file read_from_string , write_to_file or write_to_string , PyFDL will choose your handler based on either path (suffix) or directly asking for this specific handler. import pyfdl from pathlib import Path from tempfile import NamedTemporaryFile fdl = pyfdl.FDL() fdl.apply_defaults() pyfdl.write_to_string(fdl, handler_name='yaml', indent=4) pyfdl.write_to_file(fdl, path=NamedTemporaryFile(suffix='.yml', delete=False).name) If your handler doesn't provide one of the methods above or you have others exposed you can use them like so: from pyfdl.handlers import get_handler my_handler = get_handler(func_name='custom_method', handler_name='yaml') fdl = FDL() fdl.apply_defaults() assert fdl.fdl_creator == 'PyFDL' my_handler.custom_method(fdl, \"my brand\") assert fdl.fdl_creator == 'my brand'","title":"Using your handler"},{"location":"Plugins/registry/","text":"Plugin Registry The PluginRegistry is in charge of loading and keeping track of PyFDL's plugins. pyfdl.plugins.registry PluginRegistry() The PluginRegistry loads and registers all plugins and built in handlers. add_handler(handler) Add a handler to the collection of handlers Args: handler: plugin or built-in handler to add get_handler_by_name(handler_name, func_name) Get a registered handler by handler_name , and make sure it has a function ( func_name ) to call Parameters: handler_name ( str ) \u2013 name handler to look for func_name ( str ) \u2013 name of function in handler to call Returns: handler ( Union [ Handler , None] ) \u2013 Raises: error \u2013 if no handler by name and function is registered get_handler_by_suffix(suffix, func_name) Get a registered handler by suffix , and make sure it has a function ( func_name ) to call Parameters: suffix ( str ) \u2013 including the dot (\".fdl\") func_name ( str ) \u2013 name of function in handler to call Returns: handler ( Union [ Handler , None] ) \u2013 Raises: error \u2013 load_builtin() Load the built-in handlers load_plugins() Load plugins from the \"pyfdl.plugins\" namespace. get_registry(reload=False) Get the active registry containing plugins and built-in handlers Returns: registry ( PluginRegistry ) \u2013","title":"Plugin Registry"},{"location":"Plugins/registry/#plugin-registry","text":"The PluginRegistry is in charge of loading and keeping track of PyFDL's plugins.","title":"Plugin Registry"},{"location":"Plugins/registry/#pyfdl.plugins.registry","text":"","title":"registry"},{"location":"Plugins/registry/#pyfdl.plugins.registry.PluginRegistry","text":"The PluginRegistry loads and registers all plugins and built in handlers.","title":"PluginRegistry"},{"location":"Plugins/registry/#pyfdl.plugins.registry.PluginRegistry.add_handler","text":"Add a handler to the collection of handlers Args: handler: plugin or built-in handler to add","title":"add_handler"},{"location":"Plugins/registry/#pyfdl.plugins.registry.PluginRegistry.get_handler_by_name","text":"Get a registered handler by handler_name , and make sure it has a function ( func_name ) to call Parameters: handler_name ( str ) \u2013 name handler to look for func_name ( str ) \u2013 name of function in handler to call Returns: handler ( Union [ Handler , None] ) \u2013 Raises: error \u2013 if no handler by name and function is registered","title":"get_handler_by_name"},{"location":"Plugins/registry/#pyfdl.plugins.registry.PluginRegistry.get_handler_by_suffix","text":"Get a registered handler by suffix , and make sure it has a function ( func_name ) to call Parameters: suffix ( str ) \u2013 including the dot (\".fdl\") func_name ( str ) \u2013 name of function in handler to call Returns: handler ( Union [ Handler , None] ) \u2013 Raises: error \u2013","title":"get_handler_by_suffix"},{"location":"Plugins/registry/#pyfdl.plugins.registry.PluginRegistry.load_builtin","text":"Load the built-in handlers","title":"load_builtin"},{"location":"Plugins/registry/#pyfdl.plugins.registry.PluginRegistry.load_plugins","text":"Load plugins from the \"pyfdl.plugins\" namespace.","title":"load_plugins"},{"location":"Plugins/registry/#pyfdl.plugins.registry.get_registry","text":"Get the active registry containing plugins and built-in handlers Returns: registry ( PluginRegistry ) \u2013","title":"get_registry"}]}